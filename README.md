[![Build Status](https://travis-ci.com/guybrush77/rapidobj.svg?branch=master)](https://travis-ci.com/guybrush77/rapidobj)

# Introduction

Rapidobj is a single header C++17 library that loads and parses [Wavefront .obj files](https://en.wikipedia.org/wiki/Wavefront_.obj_file).

The .obj file format was first used by Wavefront Technologies around 1990. However, this 3D geometry file format did not age well. An .obj file is a text file and, consequently, large models take a lot of of disk space and are slow to load and parse. Moreover, after loading and parsing .obj files, additional processing steps are required to transform the data into a format suitable for hardware rendering.

Rapidobj library, as implied by its name, is designed to quickly load and parse large .obj files. It is optimised to take advantage of modern computer hardware and is well suited for processing large .obj files on computers with multi-core CPUs and fast solid-state disk drives. The user-facing interface is heavily influenced by another single header C++ library, [tinyobjloader](https://github.com/tinyobjloader/tinyobjloader). 

# Using Rapidobj API

The API of the rapidobj library is rather simple. It consists of just two free-standing functions: ```ParseFile()``` and ```Triangulate()```. 

Function ```ParseFile()``` loads an .obj file, parses it and returns a result object. The result object contains vertex attribute arrays, shapes, and materials. A shape object contains a collection of polygons (i.e. a mesh) or a collection of polylines.

Each polygon in a mesh may have 3 sides (triangle), 4 sides (quadrilateral), 5 sides (pentagon) - all the way up to the 255 sides maximum. Function ```Triangulate()``` takes a result object, loops through all the meshes, and decomposes polygons with more than three sides into a set of triangles. However, if the meshes were already triangulated, then the function call will do nothing.

Suppose we want to find out the total number of triangles in an .obj file. This can be accomplished by passing the .obj file path to```ParseFile()``` and triangulating the result. The next step is looping through all the meshes; in each iteration, the number of triangles in the current mesh is added to running sum. The code for this logic is shown below:

```cpp
#include "rapidobj/rapidobj.hpp"

#include <iostream>

int main()
{
    auto result = rapidobj::ParseFile("/home/user/obj-models/my-model.obj");

    if (result.error) {
        std::cout << result.error.code.message() << '\n';
        return EXIT_FAILURE;
    }

    rapidobj::Triangulate(result);

    if (result.error) {
        std::cout << result.error.code.message() << '\n';
        return EXIT_FAILURE;
    }

    auto num_triangles = size_t();

    for (const auto& shape : result.shapes) {
        num_triangles += shape.mesh.num_face_vertices.size();
    }

    std::cout << "Shapes:    " << result.shapes.size() << '\n';
    std::cout << "Triangles: " << num_triangles << '\n';

    return EXIT_SUCCESS;
}
```

# Understanding Rapidobj Result

Let's take a closer look at the ```Result``` object returned by the ```ParseFile()``` function. Its structure corresponds closely to the format of an .obj file. 
![rapidobj::Result](data/images/result.svg)
3D objects are usually represented as a set of faces and a set of vertices. A vertex has attributes, the most important of which is its position. The positions are stored as Cartesian coordinates in the ```result.attributes.positions array```. An .obj file also supports two more vertex attributes: texture coordinates (used for UV mapping) and normals. These are stored in ```result.attributes.texcoords``` and ```result.attributes.normals``` arrays.

A vertex is generated by indexing into the attributes array(s). An object of type ```Index``` defines a single vertex and it has three fields: ```position_index```, ```texcoord_index```, and ```normal_index```. Only the ```position_index``` is mandatory; a vertex might not have any normals or UV coordinates. In this case, -1 (invalid index) is stored in ```index.normal_index``` and ```index.texcoord_index```.

```Index``` objects (i.e. vertices) are stored in the ```shape.mesh.indices``` array. Because the indices array is flattened, extra information is required to distinguish individual faces. The number of vertices per face is kept in the ```shape.mesh.num_face_vertices``` array. The size of this array is equal to the number of faces in the mesh. Note that, for triangulated meshes, this complexity goes away; every entry in the ```shape.mesh.num_face_vertices``` array is 3. It is safe to assume that entries { 0, 1, 2 } of the ```shape.mesh.indices``` array form triangle face 0, entries { 3, 4, 5 } form triangle face 1, entries { 6, 7, 8 } form triangle face 2, etc.

The mesh object also contains material ids per face and smoothing group ids per face. These are stored in ```shape.mesh.material_ids``` and ```shape.mesh.smoothing_group_ids```. Material IDs index into the ```result.materials``` array. Smoothing group IDs are used to calculate vertex normals, in case they are not provided.

Meshes are not stored directly in the result object. Instead, a ```Shape``` object contains either a mesh, polylines (```Lines```), or both. The result object can contain one or more shapes.

Let's consider a concrete example:
![Simple Shape](data/images/shape.svg)
The mesh in this simple shape consists of five vertices. Moving clockwise, starting from the origin, the vertices are: v1, v2, v3, v4, and v5.

There are two faces in this mesh: a quad and a triangle. Moving clockwise, starting from the origin, the vertex indices of the quad are: 1, 2, 4, and 5. The vertex indices for the triangle are: 2, 3, and 4. 

An .obj file for this shape would then look like:
```
v  0  0  0
v  0  1  0
v .5  2  0
v  1  1  0
v  1  0  0

f  1  2  4  5
f  2  3  4
```
Running the ```ParseFile``` on this .obj file would produce the following:

![Simple Shape Result](data/images/example.svg)

There are a few things to note:
* Vertex coordinates x, y, z are interleaved in the attributes ```positions``` array (i.e. v1<sub>x</sub>, v1<sub>y</sub>, v1<sub>z</sub>, v2<sub>x</sub>, v2<sub>y</sub>, v2<sub>z</sub>, ... , v5<sub>x</sub>, v5<sub>y</sub>, v5<sub>z</sub>).
* Since we are not using texture coordinates or normals in this example, attribute ```texcoords``` and ```normals``` arrays are empty; likewise, all the mesh texcoords and normals indices are set to -1 in the mesh ```indices``` array.
* All the position indices in the mesh ```indices``` array are decremented by 1 compared to the .obj file face indices (because C/C++ arrays are zero-based).
* To index into the attribute positions array, it is necessary to multiply the mesh ```indices``` position index by 3 and then add an offset. For example, assuming position index ```n```, the effective indices for vertex position coordinates (x, y, z) are: ```(3n + 0, 3n + 1, 3n + 2)```.
* The material IDs for both faces are set to -1 in the mesh ```material_ids``` array. Value of -1 means that no material is assigned to the face.
* The smoothing group IDs for both faces are set to 0 in the mesh ```smoothing_group_ids``` array. Value of 0 indicates that the face does not belong to any smoothing group.

# Using Rapidobj Result
Typically, parsed .obj data cannot be used as is. For instance, for hardware rendering, a number of additional processing steps are required so that the data is in a format that can be easily consumed by a GPU. Rapidobj provides one convenience function, ```Triangulate()```, to assist with this task. Other tasks must be implemented by the rendering application. These may include:
* Gathering all the attributes so that the vertex data is in a single array of interleaved attributes. This step may optionally include vertex deduplication.
* Generate normals, in case they are not provided in the .obj file. This step may use smoothing groups (if any) to create higher quality normals.
* Optionally optimise the meshes for rendering based on some criteria such as: material type, mesh size, number of batches to be submitted, etc.
